<!doctype html>
<html>

<head>
	<script type="text/javascript" src="http://livejs.com/live.js"></script>
    <link rel="stylesheet" href="../main.css">
    
    <!-- Mathjax scripts -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <!-- Mathjax commands -->
    $
    \newcommand{\BB}{\mathcal{B}}
    \newcommand{\CC}{\mathbb{C}}
    \newcommand{\DD}{\mathcal{D}}
    \newcommand{\KK}{\mathbb{K}}
    \newcommand{\LL}{\mathcal{L}}
    \newcommand{\NN}{\mathbb{N}}
    \newcommand{\OO}{\mathcal{O}}
    \newcommand{\PP}{\mathcal{P}}
    \newcommand{\QQ}{\mathbb{Q}}
    \newcommand{\RR}{\mathbb{R}}
    \newcommand{\ZZ}{\mathbb{Z}}

    \renewcommand{\Re}{\operatorname{Re}}
    \renewcommand{\Im}{\operatorname{Im}}

    \newcommand{\veca}{\vec{a}}
    \newcommand{\vecb}{\vec{b}}
    \newcommand{\vecd}{\vec{d}}
    \newcommand{\vece}{\vec{e}}
    \newcommand{\vecf}{\vec{f}}
    \newcommand{\vecn}{\vec{n}}
    \newcommand{\vecp}{\vec{p}}
    \newcommand{\vecr}{\vec{r}}
    \newcommand{\vecu}{\vec{u}}
    \newcommand{\vecv}{\vec{v}}
    \newcommand{\vecw}{\vec{w}}
    \newcommand{\vecx}{\vec{x}}
    \newcommand{\vecy}{\vec{y}}
    \newcommand{\vecz}{\vec{z}}

	\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}}

	\newcommand{\norm}[1]{\lVert #1 \rVert}
    $

    <!-- Plotly code for interactive plots -->
    <script src="../plotly-2.0.0-rc.2.min.js"></script>
    
    <!--Prisim for code highlighting -->
    <script src="../prism.js"></script>    
    <link rel="stylesheet" href="../prism.css">



    
<!--************************************************************************-->
<title>Shaw Research Notes</title>
</head>
<!--***************************************************************************
*******************************************************************************
****************************************************************************-->

<body>

<div class="top-bar">
    <a href="../index.html"><img src="../frame/boulder-logo.png"></a>
</div>

<div id="side-bar" class="side-bar">
    <p><a href="../reports/reports.html" target="_top">Reports</a></p>
    <p><a href="../presentations/presentations.html" target="_top">Presentations</a></p>
    <p><a href="../todo/todo.html" target="_top">To Do List</a></p>
    <p><a href="../about/about.html" target="_top">About</a></p>
    <hr>
    <p><a href="../old-rbf/index.html" target="_top">Old Site</a></p>
</div>

<div class="page-content">
<!--***************************************************************************
*******************************************************************************
****************************************************************************-->

<h1 id="Title">February 18<sup>th</sup>, 2024</h1>
<p id="summary">
Lorem
</p>


<div id="slider-plot" style="width:auto;"></div>

<!--************************************************************************-->

<hr>
<!--********************************************************************-->

<h1>Goals and Notation</h1>

<p>
Our goal is to test RBF-QF methods. These methods are said to work on arbitrary 
sets of quadrature nodes, but in order to be accurate they require some reasonable
restrictions. One straightforward restriction is that that no two points can be
too close, else the interpolation matrices containing the two points will become
ill-conditioned. This suggests that sampling the points independently from a 
distribution over the domain is not ideal.

A more complicated condition is that points should be dense over the whole domain.
To be more precise,
<a href="https://www.worldscientific.com/worldscibooks/10.1142/6437#t=aboutBook">Fasshauer</a>
defines the <i>fill distance</i> or
<i>covering radius</i> to be
$$
h = \sup_{\vecx \in \Omega} \min_{\vec{\xi} \in \Xi} \norm{\vecx - \vec{\xi}}.
$$
This can be the interpreted as the largest distance from a point in the domain
to the nearest point in the cloud.
Equivalently, it is the radius of the largest open ball with center in the domain
that does not contain any of the points in the point 

</p>


<!--********************************************************************-->
<h1>Point Generation In the Unit Square</h1>


<!--***************************************************************************
*******************************************************************************
****************************************************************************-->
</div>

<!-- Accordion script -->
<script>
var acc = document.getElementsByClassName("accordion");
var i;

for (i = 0; i < acc.length; i++) {
  acc[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var panel = this.nextElementSibling;
    if (panel.style.display === "block") {
      panel.style.display = "none";
    } else {
      panel.style.display = "block";
    }
  });

var expand_all_accordions = true;

if (expand_all_accordions){
    for (i = 0; i < acc.length; i++) {
      acc[i].nextElementSibling.style.display = "block";
    }
}

}
</script>

<!-- Tabs script -->
<script>
function openTab(evt, tabId) {
  // Declare all variables
  var i, tabcontent, tablinks;

  // Get all elements with class="tabcontent" and hide them
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }

  // Get all elements with class="tablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }

  // Show the current tab, and add an "active" class to the button that opened the tab
  document.getElementById(tabId).style.display = "block";
  evt.currentTarget.className += " active";
}
</script>

</body>
    
</html>
